using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.WUI.Reactive
{
  public module JsASTOptimizer
  { 
    allowedForAssignment : list[Type] = [typeof(JsAST.Call), typeof(JsAST.MethodRef), typeof(JsAST.LocalRef), 
                                         typeof(JsAST.Literal), typeof(JsAST.Code), typeof(JsAST.Void), 
                                         typeof(JsAST.Ternary), typeof(JsAST.NotImpl)];
    allowedCallTargets : list[Type] = [typeof(JsAST.LocalRef), typeof(JsAST.Literal)];
    
    public Optimize(ast : JsAST) : JsAST
    {  
        
        mutable counter = 0;        
        JsAST.Recurse(ast, a : JsAST => {
        counter++;
        def varName = "$__da" + counter;
        match(a) {
        | Call(OpCode("==="), something :: Literal(Bool(true)) :: []) 
        | Call(OpCode("==="), Literal(Bool(true)) :: something :: [])       => something
        | Call(OpCode as op, Call(MethodRef(Seq as seq,  m), parms) as call :: rest) => 
            JsAST.Seq([JsAST.DefValue(varName, JsAST.Void()),
                       DelayAssignment(call, JsAST.LocalRef(varName)),
                       JsAST.Call(op, JsAST.LocalRef(varName) :: rest)])
        | Call(OpCode as op, head :: (Call(MethodRef(Seq as seq,  m), parms) as call) :: []) => 
            JsAST.Seq([JsAST.DefValue(varName, JsAST.Void()),
                       DelayAssignment(call, JsAST.LocalRef(varName)),
                       JsAST.Call(op, [head, JsAST.LocalRef(varName)])])
        | Call(OpCode(op), something :: Literal(Null) :: []) 
        | Call(OpCode(op), Literal(Null) :: something :: [])             => 
            JsAST.Call(JsAST.OpCode("&&"), [JsAST.Call(JsAST.OpCode(op), [something, JsAST.Literal(JsLiteral.Null())]), JsAST.Call(JsAST.OpCode(op), [JsAST.TypeOf(something), JsAST.Literal(JsLiteral.String("undefined"))])])
        | If(Call(func, something :: If(c, t, e) :: []), then, els)
        | If(Call(func, If(c, t, e) :: something :: []), then, els)         => JsAST.If(JsAST.Call(func, JsAST.Ternary(c, t, e) :: [something]), then, els)
        | If(Call(OpCode as op, Seq as seq :: rest), then, els)             =>             
            JsAST.Seq([JsAST.DefValue(varName, JsAST.Void()), 
                        DelayAssignment(seq, JsAST.LocalRef(varName)),
                        JsAST.If(JsAST.Call(op, JsAST.LocalRef(varName) :: rest), then, els)]);                           
        | If(Call(OpCode as op, Call(MethodRef(Seq as seq,  m), parms) :: rest), then, els)            =>             
            JsAST.Seq([JsAST.DefValue(varName, JsAST.Void()), 
                        DelayAssignment(seq, JsAST.LocalRef(varName)),
                        JsAST.If(JsAST.Call(op, JsAST.Call(JsAST.MethodRef(JsAST.LocalRef(varName), m), parms) :: rest), then, els)]);        
        | If(Call(OpCode as op, Call as call :: rest), then, els) =>             
            JsAST.Seq([JsAST.DefValue(varName, call), 
                       JsAST.If(JsAST.Call(op, JsAST.LocalRef(varName) :: rest), then, els)])
        | DefValue(l, r) when allowedForAssignment.Any(al => al == r.GetType()) => a
        | Assign(l, r) when allowedForAssignment.Any(al => al == r.GetType()) => a
        | Assign(left, expr)   => DelayAssignment(expr, left);
        | DefValue(left, expr) => JsAST.Seq([JsAST.DefValue(left, JsAST.Void()), DelayAssignment(expr, JsAST.LocalRef(left))]);
        | Array(xs) => 
            JsAST.Array(xs.Flatten(x => match(x) {
            | JsAST.Array(xs2) => xs2
            | x => [x]
            }))            
        | _ => a
        }}, false)
    }
    
    public RemoveEmptyBranches(ast : JsAST) : JsAST
    {
        JsAST.Recurse(ast, a : JsAST =>
        match(a) { 
        | While(_, Void) 
        | While(_, Undefined) => JsAST.Void()
        | If(cond, then, Undefined) 
        | If(cond, then, Void) => JsAST.JustIf(cond, then)
        | JustIf(_, Void) 
        | JustIf(_, Undefined) => JsAST.Void()        
        | _ => a
        }, false);
    }
    
    public FlattenAndRemoveVoids(ast : JsAST) : JsAST    
    {
        JsAST.Recurse(ast, a : JsAST => {
            def flatten(a' : JsAST) : JsAST {
            | Seq(s0) when s0.Any(e => e is JsAST.Seq)  => 
                def r = s0.Flatten(e => 
                    match(e) {
                    | JsAST.Seq(xs) => xs
                    | x => [x]
                });
                flatten(JsAST.Seq(r.Filter(rr => !(rr is JsAST.Void))));
            | _ => a'
            }
            flatten(a);
        });
    }
    
    public LabelsToSwitch(ast : JsAST) : JsAST 
    {
        def gotos = IterateAST(ast).OfType.[JsAST.Goto]().ToDictionary(k => k.LabelId);
        def r = JsAST.Recurse(ast, a : JsAST => 
        match(a) {
        | Label(id, body) when gotos.ContainsKey(id) => JsAST.WhileNamed(JsAST.Literal(JsLiteral.Bool(true)), JsAST.Seq([body, JsAST.Break()]), "l" + id.ToString()); //ConvertLabelToSwitch(l)
        | Label(_, body)  => body
        | Goto(id)        => JsAST.Continue("l" + id.ToString())
        | _ => a
        });        
        r
    }    
    
    ConvertLabelToSwitch(ast : JsAST.Label) : JsAST
    {        
        def currentLabel = $"__current$(ast.Id)";
        def currentLabelDef = JsAST.DefValue(currentLabel, JsAST.Literal(JsLiteral.Integer(ast.Id)));
        
        def ast = JsAST.Recurse(ast, a : JsAST => 
        match(a) {
        | Goto(labelId) => JsAST.Seq([JsAST.Assign(JsAST.LocalRef(currentLabel), JsAST.Literal(JsLiteral.Integer(labelId))),
                                      JsAST.Break()])
        | _ => a
        });
        
        def cases = IterateAST(ast).OfType.[JsAST.Label]().Map(l => JsAST.SwitchCase(l.Id, l.Body));
        def switch = JsAST.Switch(JsAST.LocalRef(currentLabel), cases);
        def while_ = JsAST.While(JsAST.Literal(JsLiteral.Bool(true)), switch);
        JsAST.Seq([currentLabelDef, while_]);
    }
    
    DelayAssignment(expr : JsAST, left : JsAST) : JsAST
    {
        def delayAssignment = DelayAssignment(_, left);
        match(expr) {
        | Seq(exprs) => 
            def newExprs = match(exprs.Rev()) {
            | last :: allButLast => delayAssignment(last) :: allButLast
            | r => r
            }
            JsAST.Seq(newExprs.Rev())
        | TryFinally(b, h) => JsAST.TryFinally(delayAssignment(b), delayAssignment(h))
        | Assign(l, r)     => JsAST.Assign(l, delayAssignment(r))
        | If(c, t, e)      => JsAST.If(c, delayAssignment(t), delayAssignment(e))
        | Switch(e, cases) => JsAST.Switch(e, cases.Map(c => JsAST.SwitchCase(c.Id, delayAssignment(c.Body))))
        | WhileNamed(c, b, n) => 
            def newBody = match(b) {
            | Seq(bodyItems) => 
                def newItems = match(bodyItems.Rev()) {
                | Break :: secondToLast :: rest => JsAST.Break() :: delayAssignment(secondToLast) :: rest;
                | last :: rest => delayAssignment(last) :: rest;
                }
                JsAST.Seq(newItems.Rev())
            | something => JsAST.Assign(left, delayAssignment(something))
            }
            JsAST.WhileNamed(c, newBody, n)
        | e when allowedForAssignment.Any(al => al == e.GetType()) => JsAST.Assign(left, e)
        | Undefined
        | Void => JsAST.Void()
        | NotImpl => expr
        }
    }
    
    public MakeReturn(ast : JsAST) : JsAST 
    {
        JsAST.Seq([JsAST.DefValue("__returnValue", JsAST.Void()), DelayAssignment(ast, JsAST.LocalRef("__returnValue")), JsAST.Return(JsAST.LocalRef("__returnValue"))])        
    }
    
    IterateAST(ast : JsAST) : IEnumerable[JsAST] 
    {
        def lst = List();
        _ = JsAST.Recurse(ast, a => {
            lst.Add(a);
            a
        });
        lst
    }
  }
}
