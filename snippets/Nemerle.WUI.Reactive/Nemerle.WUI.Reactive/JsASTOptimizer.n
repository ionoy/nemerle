using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.WUI.Reactive
{
  public module JsASTOptimizer
  {
    public Optimize(ast : JsAST) : JsAST
    {   
    //Foreach
    
    //Structural
    | Call(OpCode("==="), something :: Literal(Bool(true)) :: []) 
    | Call(OpCode("==="), Literal(Bool(true)) :: something :: [])        => Optimize(something)
    | If(Call(func, something :: If(c, t, e) :: []), then, els)
    | If(Call(func, If(c, t, e) :: something :: []), then, els)         => Optimize(JsAST.If(JsAST.Call(func, JsAST.Ternary(c, t , e) :: [something]), then, els))
    | If(cond, then, Undefined)                                         => JsAST.JustIf(Optimize(cond), Optimize(then))
    
    //Optimize parts
    | Seq(items)                                                        => JsAST.Seq(items.Map(Optimize))      
    | If(cond, then, els)                                               => JsAST.If(Optimize(cond), Optimize(then), Optimize(els))
    | Ternary(cond, then, els)                                          => JsAST.Ternary(Optimize(cond), Optimize(then), Optimize(els))
    | For(it, coll, body)                                               => JsAST.For(it, coll, Optimize(body))
    | Call(func, parms)                                                 => JsAST.Call(Optimize(func), parms.Map(p => Optimize(p)))      
    | MethodRef(obj, meth)                                              => JsAST.MethodRef(Optimize(obj), meth)
    | _ => ast
    }
    
    public FlattenAndRemoveVoids(ast : JsAST) : JsAST
    {
    | Seq(s0) when s0.Any(e => e is JsAST.Seq)                => 
        def r = s0.Flatten(e => 
            match(e) {
            | JsAST.Seq(xs) => xs
            | x => [x]
        });
        FlattenAndRemoveVoids(JsAST.Seq(r.Filter(rr => !(rr is JsAST.Void))));
    | Seq(items)                                                        => JsAST.Seq(items.Map(FlattenAndRemoveVoids))      
    | If(cond, then, els)                                               => JsAST.If(FlattenAndRemoveVoids(cond), FlattenAndRemoveVoids(then), FlattenAndRemoveVoids(els))
    | Ternary(cond, then, els)                                          => JsAST.Ternary(FlattenAndRemoveVoids(cond), FlattenAndRemoveVoids(then), FlattenAndRemoveVoids(els))
    | For(it, coll, body)                                               => JsAST.For(it, coll, FlattenAndRemoveVoids(body))
    | Call(func, parms)                                                 => JsAST.Call(FlattenAndRemoveVoids(func), parms.Map(p => FlattenAndRemoveVoids(p)))      
    | MethodRef(obj, meth)                                              => JsAST.MethodRef(FlattenAndRemoveVoids(obj), meth)
    | _ => ast
    }
  }
}
