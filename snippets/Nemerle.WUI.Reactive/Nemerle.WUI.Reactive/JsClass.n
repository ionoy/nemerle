using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.WUI.Reactive
{
    [Record]
    public class JsClass
    {
        public ClassType : TypeBuilder { get; set; }
        public Indent : string    { get; set; }
        public IEnumerableType : TypeVar { get; set; }
        public Typer : Typer { get; set; }
        
        IsViewmodel : bool { get { !ClassType.Name.StartsWith("_N_") } }
        Constructor : IMethod { 
            get {
                def constructors = ClassType.GetConstructors(BindingFlags.Public | BindingFlags.Instance);
                when(constructors.Length > 1)
                      Message.Error(ClassType.Location, "Multiple constructors are not supported");  
                constructors.FirstOrDefault()
            }
        }
        
        public Write() : string 
        {
            def bodyIndent = Indent + "  ";
            def constructorParams = GetConstructorParams();
            def properties = GetProperties(bodyIndent);
            def fields = GetFields(bodyIndent);
            def staticFields = GetStaticFields(Indent);
            def constructorBody = GetConstructorBody(bodyIndent);
            def methods = GetMethods(bodyIndent);                        

$<#$(Indent)function $(GetProperName(ClassType))(..$constructorParams) {
$(bodyIndent)var self = this;
$properties
$fields
$constructorBody
$methods
$(Indent)}
$staticFields#>
        }
        
        /*

        */
        
        GetConstructorParams() : list[string] 
        { 
            def ctor = Constructor;
            if(ctor != null) ctor.GetParameters().Map(p => p.Name) else [];            
        }
        
        GetProperties(indent : string) : string 
        {            
            def props = ClassType.GetProperties();
            def propVal(prop : IProperty) {                
                def isArray = TypeIsArray(prop.GetGetter().ReturnType.TypeInfo);
                match((IsViewmodel, isArray)) {
                | (true, true) => "observableArray([])"
                | (true, false) => "observable()"
                | (false, true) => "[]";   
                | (false, false) => "{}";
                }
            }
            def propStrings = props.Map(p => indent + $<#this.$(p.Name) = $(propVal(p))#>);
            $<#..$(propStrings; ";\n")#>;
        }
        
        GetFields(indent : string) : string 
        {
            def fields = ClassType.GetFields().Where(f => !f.IsStatic && f.Name != "server" && !f.Name.StartsWith("_N_"));
            def fldVal(fld : IField) {
                if(TypeIsArray(fld.GetMemType().TypeInfo)) "[]" else "{}";
            }
            def fieldStrings = fields.Map(f => indent + $<#this.$(f.Name) = $(fldVal(f))#>);
            $<#..$(fieldStrings; ";\n")#>;
        }
        
        GetStaticFields(indent : string) : string 
        {
            def fields = ClassType.GetFields().Where(f => f.IsStatic);
            def fldVal(fld : IField) {
                if(fld.HasBeenAssigned) {
                    def val = fld.GetValue();
                    def a = val;
                    "{}";
                } else {
                    "{}";
                }
                    
            }
            def fieldStrings = fields.Map(f => indent + $<#$(ClassType.Name).$(f.Name) = $(fldVal(f))#>);
            $<#..$(fieldStrings; ";\n")#>;
        }
        
        GetConstructorBody(indent : string) : string 
        {
            TranslateMethodBody(Constructor :> MethodBuilder, Dictionary(), indent);
        }
        
        GetMethods(indent : string) : string 
        {
            def methodParms(method) {
                method.GetParameters().Map(p => p.Name);
            }
            def methods = ClassType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                                   .Filter(m => !m.Name.StartsWith("get_") && !m.Name.StartsWith("set_"))
                                   .Filter(m => !m.IsConstructor)
                                   .Map(m => 
$<#$(indent)this.$(m.Name) = function(..$(methodParms(m))) { 
$(TranslateMethodBody(m :> MethodBuilder, Dictionary(), indent + "  "))
$(indent)}#>);

            $<#..$(methods; "\n")#>
        }
        
        TypeIsArray(type : TypeInfo) : bool 
        {
            type.IsDerivedFrom(IEnumerableType.TypeInfo) && type.FullName != "System.String";
        }
        
        public GetMethodJsAST(method : MethodBuilder, lambdas : Dictionary[string, JsAST.Lambda]) : JsAST 
        {        
            match(method.Header.Body) {
            | FunBody.Typed(typedBody) =>
                mutable jsAst = JsASTBuilder.Build(typedBody, lambdas);
                jsAst = JsASTHelper.LabelsToNamedWhile(jsAst);
                jsAst = JsASTHelper.TransformBottomUp(jsAst);            
                jsAst = JsASTHelper.FlattenAndRemoveVoids(jsAst);
                jsAst = JsASTHelper.RemoveEmptyBranches(jsAst);
            
                when(!(method.Header.ReturnType is FixedType.Void()) && !method.IsConstructor)
                    jsAst = JsASTHelper.MakeReturn(jsAst);
                
                jsAst;        
            | FunBody.Parsed => 
                def oldEmitDebug = Typer.Manager.Options.EmitDebug;
                def body = method.Body;
                Typer.Manager.Options.EmitDebug = false;
                def methodTyper = Typer(ClassType, null, method, method.Env);
                methodTyper.RunFullTyping();
                Typer.Manager.Options.EmitDebug = oldEmitDebug;
                def jsbody = GetMethodJsAST(method, lambdas);
                method.Body = body;
                jsbody;
            | _ => 
                Message.Error("Couldn't type body"); 
                JsAST.Void();
            }
        }
    
        public TranslateMethodBody(meth : MethodBuilder, lambdas : Dictionary[string, JsAST.Lambda], indent = "" : string) : string
        {           
            def ast = GetMethodJsAST(meth, lambdas);
            ast.Write(indent);
        }
        
        public static GetProperName(type : TypeInfo) : string {
            type.FullName.Replace(".", "_")
        }
    }
}
