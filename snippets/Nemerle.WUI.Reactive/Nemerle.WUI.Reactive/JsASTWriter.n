using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.WUI.Reactive
{
  public module JsASTWriter
  {
    public Write(ast : JsAST, indent = "  " : string) : string
    {
        match(ast) {
        | Assign(s, t)                                 => indent + $"$(Write(s)) = $(Write(t))"    
        | Array(values)                                => $<#[..$(values; ","; Write(_, ""))]#>  
        | BinaryOperator(op, l, r)                     => $"$(Write(l)) $op $(Write(r))"
        | Break                                        => indent + "break"
        | Call(OpCode as op, e1 :: e2 :: [])           => $"$(Write(e1)) $(Write(op)) $(Write(e2))"
        | Call(Constructor(type), parms)               => $<#new $(type.Name)(..$(parms; ","; Write(_, "")))#>
        | Call(Indexer(obj), parms)                    => $<#$(Write(obj))[..$(parms; ","; Write(_, ""))]#>    
        | Call(op, parms)                              => $<#$(Write(op))(..$(parms; ","; Write(_, "")))#>    
        | Continue(id)                                 => indent + $"continue $id"
        | DefValue(name, Void)                         => indent + $"var $name"      
        | DefValue(name, val)                          => indent + $"var $name = $(Write(val))"
        | If(cond, then, els)                          => 
$<# 
$indent if($(Write(cond))) { 
$indent $(Write(then, indent + "  "))
$indent } else {
$indent $(Write(els, indent + "  "))
$indent }#>
        | JustIf(cond, then)                           =>
$<# 
$indent if($(Write(cond))) { 
$indent $(Write(then, indent + 1))
$indent }#>
        
        | For(iter, coll, body)                        => 
$<#
$indent for(var $iter in $(Write(coll))) {
$indent   var $iter = $(Write(coll))[$iter];
$(Write(body, indent + " "))
$indent }#>    
        | Label(id, body)                              =>
$<#
$(Write(body, indent + "  "))
#>
        | Literal(Null)                                =>  "null"
        | Literal(Integer(val))                        => $"$val"
        | Literal(Float(val))                          => $"$val"
        | Literal(String(val))                         => $<#"$val"#>
        | Literal(Bool(val))                           => $"$val"
        | LocalRef(name)                               => $"$name"
        | MethodRef(obj, meth)                         => $"$(Write(obj)).$meth"        
        | OpCode(name)                                 => $"$name"        
        | Object(fields)                               => 
                    def fieldToObjectField((name, ast)) {
            $"$name : $(Write(ast))"
        }
            $<#{ ..$(fields; ", "; fieldToObjectField) }#>
        | ParameterRef(obj, parm)                      => $"$(Write(obj)).$parm"
        | Return(expr)                                 => indent + $"return $(Write(expr))"
        | Seq(items)                                   => 
            def withoutVoids = items.Filter(i => !(i is JsAST.Void));
            $<#..$(withoutVoids; ";" + Environment.NewLine; Write(_, indent));#>               
        | Switch(expr, cases)                          =>
$<#
$indent switch($(Write(expr))) {
$indent ..$(cases; "\n"; Write(_, indent + "  "))
$indent }
#>
        | SwitchCase(id, body)                         =>
$<#
$indent $id:
$indent $(Write(body, indent + "  "))
$indent    break;
#>
        | Ternary(cond, then, els)                     => $"($(Write(cond)) ? $(Write(then)) : $(Write(els)))"  
        | This                                         => "this"    
        | Try(body, handler)                    => 
$<#
$indent try {
$indent $(Write(body, indent + "  "))
$indent } catch {
$indent $(Write(handler, indent + "  "))
$indent }
#>
        | TryFinally(body, handler)                    => 
$<#
$indent try {
$indent $(Write(body, indent + "  "))
$indent } finally {
$indent $(Write(handler, indent + "  "))
$indent }
#>
        | TypeOf(expr)                                 => $<# typeof $(Write(expr)) #>
        | Undefined                                    =>  <#"undefined"#>    
        | Void                                         => ""    
        | While(cond, body)                            =>
$<#
$indent while($(Write(cond))) {
$indent $(Write(body, indent + "  "))
$indent }
#>
        | WhileNamed(cond, body, name)                 =>
$<#
$indent $name: while($(Write(cond))) {
$indent $(Write(body, indent + "  "))
$indent }
#>
        | Code(code)                                   => code
        | NotImpl(val)                                 => $"/* Not implemented: $val */"    
        | _                                            => $"/* unknown $ast */"
        }
    }
  }
}
