using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.WUI.Reactive
{
  public module JavascriptASTOptimizer
  {
    public Optimize(ast : JavascriptAST) : JavascriptAST
    {   
    //Optimize structure
    | Call(OpCode("=="), something :: Literal(Bool(true)) :: [], _)
    | Call(OpCode("=="), Literal(Bool(true)) :: something :: [], _)     => Optimize(something)
    | If(Call(func, something :: If(c, t, e) :: [], istail), then, els)
    | If(Call(func, If(c, t, e) :: something :: [], istail), then, els) => Optimize(JavascriptAST.If(JavascriptAST.Call(func, JavascriptAST.Ternary(c, t , e) :: [something], istail), then, els))
    | If(cond, then, Literal(Undefined))                                => JavascriptAST.JustIf(Optimize(cond), Optimize(then))
    //Optimize parts
    | Sequence(items)                                                   => JavascriptAST.Sequence(items.Map(Optimize))      
    | If(cond, then, els)                                               => JavascriptAST.If(Optimize(cond), Optimize(then), Optimize(els))
    | Ternary(cond, then, els)                                          => JavascriptAST.Ternary(Optimize(cond), Optimize(then), Optimize(els))      
    | Call(func, parms, istail)                                         => JavascriptAST.Call(Optimize(func), parms.Map(p => Optimize(p)), istail)      
    | MethodRef(obj, meth)                                              => JavascriptAST.MethodRef(Optimize(obj), meth)
    | _ => ast
    }
  }
}
