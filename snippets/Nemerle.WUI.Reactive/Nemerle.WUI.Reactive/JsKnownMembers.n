using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.WUI.Reactive
{  
  module JsKnownMembers
  {
      public Convert(call : TExpr.Call, builder : TExpr -> JsAST) : JsAST
      {
        def result = match(call) {
        | Call(MethodRef(obj = o, meth = meth), parms, _) => ConvertMethod(o.Type.TypeInfo, builder(o), meth, parms.Map(p => builder(p.expr)))
        | Call(StaticRef(from = fromType, mem = meth) as left, parms, _) => ConvertMethod(fromType.TypeInfo, builder(left), meth, parms.Map(p => builder(p.expr)))
        | Call(OpCode as op, parms, _) => JsAST.Call(builder(op), parms.Map(p => builder(p.expr)))
        | Call(Base, _, _) => JsAST.Void()
        | Call(s, _, _) => Message.Warning("Unsupported call to $s"); JsAST.Void()
        }        
        result
      }
      
      public ConvertMethod(type : TypeInfo, left : JsAST, member : IMember, parms : list[JsAST]) : JsAST
      {
          type.Manager.LookupTypeInfo
        match(member.Name, parms) {
        | ("op_Inequality", _) => JsAST.Call(JsAST.OpCode("!="), parms)
        | ("ToString", h :: _) => JsAST.Call(JsAST.MethodRef(h, "toString"), [])
        | ("ToString", [])  => JsAST.Call(JsAST.MethodRef(left, "toString"), [])
        | ("Concat", h :: t) when type.FullName == typeof(string).FullName                    => JsAST.Call(JsAST.MethodRef(h, "concat"), t)
        | ("ToUpper", []) when type.FullName == typeof(string).FullName                       => JsAST.Call(JsAST.MethodRef(left, "toUpperCase"), [])
        | ("op_Implicit", h :: [])                                                            => h
        | ("op_Implicit", h :: t)                                                             => JsAST.Seq(h :: t)
        | ("op_Addition", parms)                                                              => JsAST.Call(JsAST.OpCode("+"), parms)
        //List
        | ("get_Item", h :: []) when type.SystemType.FullName == typeof(List[_]).FullName     => JsAST.Call(JsAST.Indexer(left), [h])
        | ("Add",      h :: []) when type.SystemType.FullName == typeof(List[_]).FullName     => JsAST.Call(JsAST.MethodRef(PropertyToField(left), "push"), [h])
        | ("Remove",   h :: []) when type.SystemType.FullName == typeof(List[_]).FullName     => JsAST.Call(JsAST.MethodRef(PropertyToField(left), "remove"), [h])
        | (".ctor", parms) when member.DeclaringType.FrameworkTypeName == typeof(Nemerle.Core.list[_]).FullName => JsAST.Array(parms)
        | (".ctor", parms) => JsAST.Call(JsAST.Constructor(type), parms)
        | _ when member.Name.StartsWith("get_")                                               => JsAST.PropertyGet(left, RemoveGetSet(member.Name))
        | (_, h :: []) when member.Name.StartsWith("set_")                                    => JsAST.PropertySet(left, RemoveGetSet(member.Name), h)            
        | _                                                                                   => Message.Warning(member.Location, $"$(member.Name) not implemented in JS"); JsAST.Call(JsAST.MethodRef(left, RemoveGetSet(member.Name)), parms)
        }
      }
      
      public ConvertField(typeName : string, member : IMember, parms : list[JsAST]) : JsAST
      {
        match(member.Name) {
        | _ when typeName == typeof(list[_].Nil).FullName => JsAST.Array([])
        | _ => 
            Message.Warning($"member.Name $(member.Name) unsupported by type $typeName");
            JsAST.NotImpl();
        }
      }
      
      public ConvertProperty(typeName : string, member : IMember, parms : list[JsAST]) : JsAST
      {
        match(member.Name) {
        | _ when typeName == typeof(list[_].Nil).FullName => JsAST.Array([])
        | _ => 
            Message.Warning($"member.Name $(member.Name) unsupported by type $typeName");
            JsAST.NotImpl();
        }
      }
      
      private RemoveGetSet(methodName : string) : string {
        if(IsGetSet(methodName)) methodName.Substring(4) else methodName
      }
      
      private IsGetSet(methodName : string) : bool {
          methodName.StartsWith("get_") || methodName.StartsWith("set_")
      }
      
      private PropertyToField(prop : JsAST) : JsAST
      {          
      | PropertyGet(obj, name) => JsAST.FieldRef(obj, name)
      | _ => prop
      }
  }
}
