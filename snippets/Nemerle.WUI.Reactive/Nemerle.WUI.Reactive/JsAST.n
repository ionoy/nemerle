using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Typedtree;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.WUI.Reactive
{
    public variant JsAST
    {
        | Assign         { Left : JsAST; Right : JsAST }
        | Array          { Values : list[JsAST] }
        | BinaryOperator { Op : string; Left : JsAST; Right : JsAST }
        | Break
        | Call           { Fun : JsAST; Parameters : list[JsAST]; }
        | Continue       { LoopName : string }
        | Constructor    { Type : TypeInfo }
        | DefFunction    { Obj : JsAST; Parameters : list[JsAST]; Body : JsAST }
        | DefValue       { Name : string; Val : JsAST }
        | For            { ItName : string; Collection : JsAST; Body : JsAST }
        | Goto           { LabelId : int }
        | If             { Cond : JsAST; Body : JsAST; ElseBody : JsAST }
        | Indexer        { Obj : JsAST }        
        | JustIf         { Cond : JsAST; Body : JsAST }                
        | Label          { Id : int; Body : JsAST }
        | Lambda         { Name : string; Parameters : list[string]; body : JsAST }
        | Literal        { Value : JsLiteral }
        | LocalRef       { Name : string }
        | MethodRef      { Obj : JsAST; Method : string }
        | StaticRef      { Type : string; Method : string }
        | FieldRef       { Obj : JsAST; Parameter : string }
        | PropertySet    { Obj : JsAST; PropertyName : string; Value : JsAST }
        | PropertyGet    { Obj : JsAST; PropertyName : string }
        | OpCode         { Name : string; }
        | Object         { Fields : list[(string * JsAST)] }
        | Return         { Expr : JsAST }
        | Seq            { Items : list[JsAST] }
        | Switch         { Expr : JsAST; Cases : list[JsAST.SwitchCase] }
        | SwitchCase     { Id : int; Body : JsAST }
        | ServerCall     { MethodName : string; TypeName : string; Parameters : list[string * JsAST]; Callback : JsAST }        
        | Ternary        { Cond : JsAST; Body : JsAST; ElseBody : JsAST }        
        | This
        | Try            { Body : JsAST; Handler : JsAST }
        | TryFinally     { Body : JsAST; Handler : JsAST }
        | TypeOf         { Expr : JsAST }
        | Undefined
        | UnaryOperator  { Op : string; Obj : JsAST }
        | Void
        | While          { Cond : JsAST; Body : JsAST }
        | WhileNamed     { Cond : JsAST; Body : JsAST; Name : string }
        | Code           { code : string }
        | NotImpl { 
            Val : string;
            public this() {
                Val = "";
            }
        }
        
        public static Recurse(ast : JsAST, selector : JsAST -> JsAST, topdown : bool = true) : JsAST 
        {
            def recurse = Recurse(_, selector, topdown);
            def ast' = if(topdown) selector(ast) else ast;
            
            def result = match(ast') {
            | Assign(l, r)                => JsAST.Assign(recurse(l), recurse(r))
            | Array(v)                    => JsAST.Array(v.Map(recurse))
            | BinaryOperator(o, l, r)     => JsAST.BinaryOperator(o, recurse(l), recurse(r))
            | Break                       => ast'
            | Call(func, parms)           => JsAST.Call(recurse(func), parms.Map(recurse))
            | DefFunction(obj, ps, bdy)   => JsAST.DefFunction(recurse(obj), ps.Map(recurse), recurse(bdy))
            | DefValue(name, val)         => JsAST.DefValue(name, recurse(val))
            | For(it, coll, body)         => JsAST.For(it, coll, recurse(body))
            | Goto                        => ast'        
            | If(cond, then, els)         => JsAST.If(recurse(cond), recurse(then), recurse(els))
            | JustIf(cond, then)          => JsAST.JustIf(recurse(cond), recurse(then))
            | Label(id, body)             => JsAST.Label(id, recurse(body))
            | Lambda(name, parms, body)   => JsAST.Lambda(name, parms, recurse(body))
            | Literal                     => ast'
            | LocalRef                    => ast'
            | MethodRef(obj, meth)        => JsAST.MethodRef(recurse(obj), meth)
            | OpCode                      => ast'
            | FieldRef(obj, parm)         => JsAST.FieldRef(recurse(obj), parm)
            | PropertySet(obj, prop, val) => JsAST.PropertySet(recurse(obj), prop, recurse(val))
            | PropertyGet(obj, prop)      => JsAST.PropertyGet(recurse(obj), prop)
            | Return(expr)                => JsAST.Return(recurse(expr))
            | Seq(items)                  => JsAST.Seq(items.Map(recurse))
            | ServerCall(meth, ty, parms, callback) => JsAST.ServerCall(meth, ty, parms.Map(p => (p[0], recurse(p[1]))), recurse(callback))
            | Switch(expr, cases)         => JsAST.Switch(recurse(expr), cases.Map(recurse).Cast.[JsAST.SwitchCase]().NToList())
            | Ternary(cond, then, els)    => JsAST.Ternary(recurse(cond), recurse(then), recurse(els))
            | This                        => ast'
            | Try(body, handler)          => JsAST.Try(recurse(body), recurse(handler))
            | TryFinally(body, handler)   => JsAST.TryFinally(recurse(body), recurse(handler))
            | TypeOf(expr)                => JsAST.TypeOf(recurse(expr))
            | Undefined                   => ast'            
            | UnaryOperator(op, obj)      => JsAST.UnaryOperator(op, recurse(obj))
            | Void                        => ast'        
            | While(cond, body)           => JsAST.While(recurse(cond), recurse(body))
            | WhileNamed(cnd, bdy, nme)   => JsAST.WhileNamed(recurse(cnd), recurse(bdy), nme)
            | Code                        => ast'
            | _ => ast'
            }
            
            if(topdown) result else selector(result)
        }        
    }
}
