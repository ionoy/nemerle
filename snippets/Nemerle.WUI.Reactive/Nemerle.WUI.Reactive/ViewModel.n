using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using BF = System.Reflection.BindingFlags;
using TExpr = Nemerle.Compiler.Typedtree.TExpr;

namespace Nemerle.WUI.Reactive
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder)
  {
    ViewModelImpl.DoTransformBeforeInheritance(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder) 
  {
    ViewModelImpl.DoTransformBeforeTypedMembers(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder) 
  {
    ViewModelImpl.DoTransform(tb, Macros.ImplicitCTX())
  }
  
  module ViewModelImpl
  {
    Ident = "  ";
    
    public DoTransformBeforeInheritance(tb : TypeBuilder, typer : Typer) : void
    {
      //assert2(false);
      Macros.DefineCTX(typer);
      def vmInterface = <[ ttype: Nemerle.WUI.Reactive.IViewModel ]>;
      def superTypes = tb.GetDirectSuperTypes();
      
      unless (superTypes != null && superTypes.Exists(t => t.Equals(vmInterface)))
        tb.AddImplementedInterface(<[ Nemerle.WUI.Reactive.IViewModel ]>);
                
      
    }
    
    public DoTransformBeforeTypedMembers(tb : TypeBuilder, typer : Typer) : void
    {
      //assert2(false);
            
      def processMember(member : ClassMember) : void
      {
        | Field(ty=ty) as field =>
          match (ty)
          {
            | <[ VMArray[..$args] ]> when args.Length > 1 => 
              //assert2(false);
              field.ty = MakeNestedViewModel(tb, typer, field.Name, args);
              
            | _ => ()
          }
          
        | _ => ()
      }
      
      match (tb.Ast)
      {
        | TopDeclaration.Class(decls=decls) => foreach (d in decls) processMember(d)
        | _ => ()
      }
    }
    
    public DoTransform(tb : TypeBuilder, typer : Typer) : void
    {
      Macros.DefineCTX(typer);
      
      def serverClass = tb.DeclaredNestedTypes.FirstOrDefault(t => t.Name == "Server");
      def serverMethods = Dictionary();
      when(serverClass != null)
      {          
          def env = typer.Manager.CoreEnv;
          def env = env.EnterIntoNamespace(tb.NamespaceNode);
          def controllerName = tb.Name + "Controller";
          def field = <[ decl: _server : $(serverClass.Name : usesite) = $(serverClass.Name : usesite)() ]>;          
          def ctb = env.Define(<[ decl: 
            public class $(controllerName : usesite) : System.Web.Mvc.Controller
            {}
          ]>);
          ctb.Define(field);
                 
          def ptb = tb.DefineNestedType(<[ decl:
              class ServerProxy
              {}
          ]>);          
          tb.Define(<[ decl: server : ServerProxy = ServerProxy() ]>);
          
          foreach(member in serverClass.GetMembers()) {
              | method is IMethod when !method.IsConstructor && method.DeclaringType.FullName == serverClass.FullName => 
                  def parameters = method.GetParameters().Map(p => <[ $(p.Name : usesite) : $(p.ty : typed) ]>);              
                  def fparms = parameters.Map(PParameter);
                  def methodName = ctb.ParsedName.NewName(method.Name);
                            
                  ctb.Define(<[ decl: 
                    public $(methodName : name) (..$fparms) : System.Web.Mvc.JsonResult 
                    {
                        def result = _server.$(method.Name : dyn)(..$parameters);
                        Json(result, System.Web.Mvc.JsonRequestBehavior.AllowGet);
                    }
                  ]>);
                  
                  serverMethods.Add(method.Name, fparms);
                  def fparms = fparms.Append([<[ parameter: callback : int -> void ]>]);
                  
                  ptb.Define(<[ decl:                   
                    public $(methodName : name) (..$(fparms)) : void
                    {}
                  ]>);
              | _ => ()              
          }
          
          ptb.Compile();
          ctb.Compile();
      }
        
      def convertMethod(name : string, meth : MethodBuilder, isDependent = true) : PExpr
      {
        #region Type method body
        def typer = typer;
        def body = meth.Body;
        def oldEmitDebug = typer.Manager.Options.EmitDebug;
        typer.Manager.Options.EmitDebug = false;
        def methodTyper = Typer(tb, null, meth, meth.Env);
        methodTyper.RunFullTyping();
        typer.Manager.Options.EmitDebug = oldEmitDebug;
        #endregion
        
        //assert2(false);
        def exprs = 
          match (body)
          {
            | PExpr.Sequence(body2) => body2
            | _                     => [body]
          };
        def scriptExprs = exprs.Map(e => DoTransformExpr(tb, typer, Ident, e, serverMethods));
        
        def scriptBody =
        if (isDependent)
            match (scriptExprs.DivideLast())
            {
              | ([], last)     => Ident + "return " + last.Trim()
              | (exprs2, last) => $<#..$(exprs2; ";\n");\n$Ident#> + "return " + last.Trim()
            }
        else
          $<#$Ident..$(scriptExprs; $";\n$Ident")#>;

        match(meth.Header.Body) { 
          | FunBody.Typed(typedBody) =>  
            def jsAst = JavascriptASTBuilder.Build(typedBody, true);
            def optimizedAst = JavascriptASTOptimizer.Optimize(jsAst);
            def js = JavascriptASTWriter.Write(optimizedAst);
            
            match(jsAst, js)
            {
                _ => ()
            }
          | _ => Message.Error("Couldn't type body");
        }
      
        meth.Body = body;
                
        def code = 
          if (isDependent)
          $<#
viewModel.$name = ko.dependentObservable(
  function()
  {
    $scriptBody;
  }, viewModel);#>
          else
$<#
viewModel.$name =
  function()
  {
    $scriptBody;
  };#>;
        <[ $(code : string) ]>
      }
      
      def convertMember(member : IMember) : PExpr
      {
        | meth is MethodBuilder when meth.Name.StartsWith("get_") || meth.Name.StartsWith("set_") => null //TODO: Add property IMethod.IsAccessor
        | meth is MethodBuilder when meth.IsConstructor => null
        | meth is MethodBuilder when meth.ReturnType is FixedType.Void =>
          convertMethod(meth.Name, meth, false)
        
        | prop is PropertyBuilder when prop.AutoPropertyField.IsSome =>
          //assert2(false);
          def arrayType = <[ ttype: Nemerle.WUI.Reactive.VMArray[_] ]>;
          def isArray = prop.Getter.ReturnType.TryUnify(arrayType);
          def ctor = if (isArray) "observableArray" else "observable";
          def prefix = $<#viewModel.$(prop.Name) = ko.$ctor(#>;
          <[ $(prefix : string) 
            + Nemerle.WUI.Reactive.Utils.ToJson(this.$(prop.Ast.name))
            + $(<#);#> : string) ]>
          
        | prop is PropertyBuilder when prop.CanRead && !prop.CanWrite => 
          convertMethod(prop.Name, prop.GetGetter() :> MethodBuilder)

        | meth is MethodBuilder when meth.Header.ParametersDeclarations.Length == 0 =>
          convertMethod(meth.Name, meth)
          
        | _ => Message.Error(member.Location, "Unsupported member"); null
          
      }
      
      def members = tb.GetMembers(BF.DeclaredOnly | BF.Instance | BF.Public);
      def exprs1 = members.RevMap(convertMember).RevFilter(_ != null);
      def exprs2 = exprs1.Map(e => <[ _ = sb.AppendLine($e) ]>);
      
      _ = tb.DefineWithSource(<[ decl:
        public GetViewModelScript() : string
        {
          def sb = System.Text.StringBuilder();
          _ = sb.AppendLine("var viewModel = { };");
          { ..$exprs2 }
          _ = sb.AppendLine("ko.applyBindings(viewModel);");
          sb.ToString()
        }
        ]>);

      _ = tb.DefineWithSource(<[ decl:
        public ToJson() : string
        {
          assert2(false);
          "!!! Not implemented yet !!!"
        }
        ]>);
        
      _ = tb.DefineWithSource(<[ decl:
          protected js(function : string) : string
          {""}
        ]>);
    }
    
    public DoTransformExpr(tb : TypeBuilder, typer : Typer, ident : string, expr : PExpr, serverMethods : Dictionary[string, list[PParameter]]) : string
    {
      Macros.DefineCTX(typer);
      def doExpr : PExpr -> string = DoTransformExpr(tb, typer, ident, _, serverMethods);
      def manager = typer.Manager;
      def convertTi = manager.LookupTypeInfo("System.Convert", 0);
      def isToStr(m : object) : bool
      {
        | TExpr.StaticRef(mem=m) => m.DeclaringType.Equals(convertTi) && m.Name == "ToString"
        | _ => false
      }
      def isThisAccess(m : object) : bool
      {
        | TExpr.PropertyMember(TExpr.This, _) => true
        | _ => false
      }
      def isBinOperator(op : PExpr) : bool
      {
        match (op.ToString())
        {
          | ">" | "<" | ">=" | "<=" | "==" | "!=" | "%" | "+" | "-" 
          | "/" | "*" | "^" | "&&" | "||"
          => true
          
          | _ => false
        }
      }
      def convertProperty(obj, prop) : string
      {
          def knownProps = [("System.String", "Length", "length"), 
          ];
          
          match(knownProps.FirstOrDefault(p => p[0] == obj.Type.TypeInfo.FullName && p[1] == prop.Name)) {
              | t => $"$(obj.ToString()).$(t[2])"
              | _ => $"/* Unknown property $(obj.Type.TypeInfo.FullName).$(prop.Name) */"
          }
      }
      
      Message.Warning(expr.ToString());
      
      match (expr)
      {        
        | PExpr.Literal => expr.ToString()
        | PExpr.TypeConversion as te => doExpr(te.expr)
        | PExpr.TypeEnforcement as te => doExpr(te.expr)
        | PExpr.Ref as r => r.name.Id
        | PExpr.MacroCall(Name(Id = "js"), _, parms) => {
            def xs = parms.Map(s => 
                  match(s) {
                    | SyntaxElement.Expression(PExpr.Call(func, parms)) => $<# $func(..$(parms; ","; doExpr)) #> 
                    | _ => "";
                  }
                );
            $" ..$xs ";
        }
        | PExpr.Sequence([e]) => DoTransformExpr(tb, typer, ident, e, serverMethods)
        | PExpr.Sequence(exprs) => 
          def ident2 = ident + Ident;
          def exors2 = exprs.Map(e => DoTransformExpr(tb, typer, ident2, e, serverMethods));
          $<#{..$(exors2; ""; x => $"$ident2$x;")#> + $"$ident}\n"
        | <[ this.server.$method(..$parms) ]> =>
            def callback = parms.Last();
            def parmValues = parms.Take(parms.Length - 1);
            def parameters = if(serverMethods.ContainsKey(method.ToString())) serverMethods[method.ToString()] else [];
            def parameters = parameters.Zip(parmValues, (f, s) => $"$(f.Name) : $(s.ToString())");
            
            match(callback) {
                | <[ $result => $body ]>=> {
                    /*..$(parameters; ':'; p => p. )*/
                    $" jQuery.get('/$(tb.Name)/$method', { ..$parameters }, function($result) { " +
                    $"  $(doExpr(body))  " +
                     "  })";
                }
                | _ => ""    
        }
        | <[ this.$(name : name) ]> when isThisAccess(expr.TypedObject)
        | <[ $(name : name) ]> when isThisAccess(expr.TypedObject) => 
          def arrayType = <[ ttype: Nemerle.WUI.Reactive.VMArray[_] ]>;
          match (expr.TypedObject)
          {
            | TExpr.PropertyMember as prop when prop.Type.TryUnify(arrayType) => $"this.$name"
            | _ => $"this.$name()"
          }          
            
        | <[ $e1.$(name : name) ]> => 
          //assert2(false);
          def result = 
            match (expr.TypedObject)
            {
              | TExpr.MethodRef(obj, meth, type_parms, notvirtual) => 
                def name2 =
                  if (meth.IsCustomAttributeDefined("Nemerle.WUI.Reactive.JsNameAttribute"))
                  {
                    //assert2(false);
                    def ti = manager.LookupTypeInfo("Nemerle.WUI.Reactive.JsNameAttribute", 0);
                    match (meth.GetModifiers().FindAttributeWithArgs(ti, typer.Env))
                    {
                      | Some((a, [<[ $(str : string) ]>])) => _ = a; str //[PExpr.Literal(Literal.String(str))]
                      | _ => name.ToString()
                    }
                  }
                  else
                    name.ToString();
                    
                _ = obj; _ = type_parms; _ = notvirtual;
                    
                $"$(doExpr(e1)).$name2"
                
              | TExpr.StaticRef => "[]"
              | TExpr.PropertyMember(obj, prop) => convertProperty(obj, prop);              
              | _ => 
              assert2(false);
              ""
            };
            
          result
          
        | <[ $e1 = $e2 ]> when isThisAccess(e1.TypedObject) => $"this.$e1($(doExpr(e2)))"
        | <[ $e1 = $e2 ]> => $"$e1 = $(doExpr(e2))";
        | <[ when ($cond) $e ]> =>
          def e2 = 
            match (e)
            {
              | PExpr.Sequence => ident + DoTransformExpr(tb, typer, ident, e, serverMethods)
              | _              => ident + Ident + DoTransformExpr(tb, typer, ident + Ident, e, serverMethods)
            };
          $"$(ident)if ($(doExpr(cond)))\n$e2"
        | <[ if($cond) $ifbody else $elsebody ]> => 
            //assert2(false);
            def cond2 = doExpr(cond);
            def ifbody2 = doExpr(ifbody);
            def elsebody2 = doExpr(elsebody);
            $"if$cond2 \n" +
            $"    $ifbody2; \n" +
             "else \n" +
            $"    $elsebody2"
        | <[ string.Concat(..$args) ]> =>
          //assert2(false);
          def removeToString(e : PExpr) : PExpr
          {
            | <[ $func($e2) ]> when isToStr(func.TypedObject) => removeToString(e2)
            | <[ $e2 : $t ]> when t.TypedObject != null && t.TypedObject.Equals(typer.InternalType.String) => removeToString(e2)
            | _ => e
          }
          def args2 = args.Map(removeToString);
          $<#"".concat(..$(args2; ", "; doExpr))#>
          
        | <[ $op($e1, $e2) ]> when isBinOperator(op) => $"($(doExpr(e1)) $op $(doExpr(e2)))"
        | <[ ++ $e ]> when isThisAccess(e.TypedObject)
        | <[ $e ++ ]> when isThisAccess(e.TypedObject) => $"this.$e(this.$e() + 1)"
        | <[ -- $e ]> when isThisAccess(e.TypedObject)
        | <[ $e -- ]> when isThisAccess(e.TypedObject) => $"this.$e(this.$e() - 1)"
        | <[ $_($_) ]> when expr.TypedObject is TExpr.MacroEnvelope =>
          def m = expr.TypedObject :> TExpr.MacroEnvelope;
          DoTransformExpr(tb, typer, ident, m.expandedPExpr, serverMethods)
          
| <[ $func(..$exprs) ]> => 
  match(func, exprs) {
    | (<[ Nemerle.IO.sprint ]>, PExpr.Literal(Literal.String(_)) as lit :: []) =>
        def strExpr = StringTemplate.Helper.SprintImpl(lit, true, e => e, tb.GlobalEnv);                    
        $"$(doExpr(strExpr))"
    | (<[ Convert.ToString ]>, p :: []) => doExpr(p)
    | _ => $<#$(doExpr(func))(..$(exprs; ", "; doExpr))#>
  }
        | <[ def $e1 = $e2 ]>
        | <[ mutable $e1 = $e2 ]> => $"var $e1 = $(doExpr(e2))"
        | <[ foreach($el in $coll) $body ]> => $"for(var $el in $coll) { var $el = $coll[$el]; $(doExpr(body)) }";
        | null => ""
        | _ =>
          //assert2(false);
          def ty = expr.GetType().Name;
          Message.Warning(expr.Location, $"JavaScript translator: no convertion for '$expr' PExpr.$ty."
            .Replace("\r\n", " ").Replace("\n", " ").Replace("\r", " "));
          expr.ToString()
      }
    }
    
    /// Create nested type with given properties and return name of created type.
    public MakeNestedViewModel(tb : TypeBuilder, typer : Typer, typeName : string, props : list[PExpr]) : PExpr
    {
      //assert2(false);
      typer.Manager.MacroColors.PushUseSiteColor();
      
      try
      {
        def makeProp(propDef : PExpr) : ClassMember
        {
          | <[ $(name : name) : $ty ]> => <[ decl: public $(name : name) : $ty { get; set; } ]>
          | _ => Message.FatalError(propDef.Location, "Incorrect format of property defenition. Use: Name : type")
        }
        def name = "T" + typeName;
        def props2 = props.Map(makeProp);
        
        def nested = tb.DefineNestedType(<[ decl:
          [Nemerle.Core.Record, Nemerle.WUI.Reactive.ViewModel]
          public class $(name : dyn) : Nemerle.WUI.Reactive.IViewModel
          {
            ..$props2
          }
          ]>);
          
        nested.Compile();
          
        <[ Nemerle.WUI.Reactive.VMArray[$(tb.Ast.PName : name).$(name : dyn)] ]>
      }
      finally { typer.Manager.MacroColors.PopColor(); }
    }
  }
  
  variant JsAST
  {
      
  }
}
