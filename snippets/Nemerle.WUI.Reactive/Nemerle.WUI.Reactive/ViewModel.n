using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Globalization;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using BF = System.Reflection.BindingFlags;
using TExpr = Nemerle.Compiler.Typedtree.TExpr;

namespace Nemerle.WUI.Reactive
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder)
  {
    ViewModelImpl.DoTransformBeforeInheritance(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder) 
  {
    ViewModelImpl.DoTransformBeforeTypedMembers(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder) 
  {
    ViewModelImpl.DoTransform(tb, Macros.ImplicitCTX())
  }
  
  module ViewModelImpl
  {    
    public DoTransformBeforeInheritance(tb : TypeBuilder, typer : Typer) : void
    {
      Macros.DefineCTX(typer);
      def vmInterface = <[ ttype: Nemerle.WUI.Reactive.IViewModel ]>;
      def superTypes = tb.GetDirectSuperTypes();
      
      unless (superTypes != null && superTypes.Exists(t => t.Equals(vmInterface)))
        tb.AddImplementedInterface(<[ Nemerle.WUI.Reactive.IViewModel ]>);
    }
    
    public DoTransformBeforeTypedMembers(tb : TypeBuilder, typer : Typer) : void
    {
        Macros.DefineCTX(typer);
        assert2(false);
        def c = JsClass(tb, "", <[ ttype : System.Collections.IEnumerable ]>, typer);
        _ = c.Write(); //Generate lambdas
    }
    
    public DoTransform(tb : TypeBuilder, typer : Typer) : void
    {            
      Macros.DefineCTX(typer);
      
      def serverClass = tb.DeclaredNestedTypes.FirstOrDefault(t => t.Name == "Server");
      def serverMethods = Dictionary();
      when(serverClass != null)
      {          
          def env = typer.Manager.CoreEnv;
          def env = env.EnterIntoNamespace(tb.NamespaceNode);
          def controllerName = tb.Name + "Controller";
          def field = <[ decl: _server : $(serverClass.Name : usesite) = $(serverClass.Name : usesite)() ]>;          
          def ctb = env.Define(<[ decl: 
            public class $(controllerName : usesite) : System.Web.Mvc.Controller
            {}
          ]>);
          ctb.Define(field);
                 
          def ptb = tb.DefineNestedType(<[ decl:
              class ServerProxy
              {}
          ]>);          
          tb.Define(<[ decl: server : ServerProxy = ServerProxy() ]>);
          
          foreach(member in serverClass.GetMembers()) {
              | method is IMethod when !method.IsConstructor && method.DeclaringType.FullName == serverClass.FullName => 
                  def parameters = method.GetParameters().Map(p => <[ $(p.Name : usesite) : $(p.ty : typed) ]>);              
                  def fparms = parameters.Map(PParameter);
                  def methodName = ctb.ParsedName.NewName(method.Name);
                            
                  ctb.Define(<[ decl: 
                    public $(methodName : name) (..$fparms) : System.Web.Mvc.JsonResult 
                    {
                        def result = _server.$(method.Name : dyn)(..$parameters);
                        Json(result, System.Web.Mvc.JsonRequestBehavior.AllowGet);
                    }
                  ]>);
                  
                  serverMethods.Add(method.Name, fparms);
                  
                  def fparms = fparms.Append([<[ parameter: callback : $(method.ReturnType : typed) -> void ]>]);
                  
                  ptb.Define(<[ decl:                   
                    public $(methodName : name) (..$(fparms)) : void
                    {}
                  ]>);
              | _ => ()              
          }
        
          ptb.Compile();
          ctb.Compile();
      }
    
      assert2(false);
      def ienType = <[ ttype : System.Collections.IEnumerable ]>;
      def cl = JsClass(tb, "  ", ienType, typer);
      def result = cl.Write();
      def a = result; 
      
      foreach(m is MethodBuilder in tb.GetMethods()) {
        def methodTyper = Typer(tb, null, m, typer.Env);        
        methodTyper.RunFullTyping();
      } otherwise {
        Message.Error("ViewModel doesn't contain any methods to type. Please, at least declare a constructor.");
      }
      
      def getJsLambda(typeInfo, methodName) {
          def apply = typeInfo.GetMembers().FirstOrDefault(m => m.Name == methodName) :> MethodBuilder;
          def lambdaBody = GetMethodJsAST(typer, typeInfo, apply, Dictionary());
          def parms = apply.GetParameters().Map(p => p.Name); 
          (typeInfo.Name, JsAST.Lambda(typeInfo.Name, parms, lambdaBody))
      }      
      def lambdas = tb.DeclaredNestedTypes.Flatten(t => 
        match(t.BaseClass) {
        | bc when bc.TypeInfo.Name == "Function"     => [getJsLambda(t, "apply")]
        | bc when bc.TypeInfo.Name == "FunctionVoid" => [getJsLambda(t, "apply_void")]
        | _ => []
        }
      ).ToDictionary(l => l[0], l => l[1]);
      
      def convertMethod(type : TypeInfo, name : string, meth : MethodBuilder, isDependent = true) {       
        def scriptBody = TranslateMethodBody(typer, type, meth, lambdas);                
        def code = if (isDependent)
$<#this.$name = ko.computed(function() {
   $scriptBody
   }, this);#>
        else {
            def parms = meth.GetParameters().Map(p => p.Name);
$<#this.$name = function(..$parms) {
   $scriptBody
   };#>;
        }
        
        code
      }
            
      def convertMember(member : IMember) {
        | meth is MethodBuilder when meth.Name.StartsWith("get_") || meth.Name.StartsWith("set_") => null //TODO: Add property IMethod.IsAccessor
        | meth is MethodBuilder when meth.IsConstructor => null
        | meth is MethodBuilder => convertMethod(member.DeclaringType, meth.Name, meth, false)
        | prop is PropertyBuilder when prop.AutoPropertyField.IsSome =>          
          def arrayTypes = [<[ ttype: Nemerle.Core.list[_] ]>, <[ ttype: System.Collections.Generic.List[_] ]>];
          def isArray = arrayTypes.Any(t => prop.Getter.ReturnType.TryUnify(t));
          def ctor = if (isArray) "observableArray([])" else "observable()";
          $<#this.$(prop.Name) = ko.$ctor;#>;
          //def paramName = char.ToLower(prop.Name[0]) + prop.Name.Substring(1);
        | prop is PropertyBuilder when prop.CanRead && !prop.CanWrite => convertMethod(member.DeclaringType, prop.Name, prop.GetGetter() :> MethodBuilder)
        | _ =>  null          
      } 
      
      def createJsTypeBody(type: TypeInfo) {          
          def members = type.GetMembers(BF.DeclaredOnly | BF.Instance | BF.Public | BF.NonPublic);
          def exprs1 = members.RevMap(convertMember).RevFilter(_ != null);
          
          def constructor = GetTypeConstructor(type);
          def constructorParams = if(constructor != null) constructor.GetParameters().Map(p => p.Name) else [];                          
          def constructorBody = TranslateMethodBody(typer, type, constructor :> MethodBuilder, lambdas);
          
          def ctor = constructor :> MethodBuilder;
          def addParams(parms, expr) : PExpr {
              match(parms) {
              | head :: tail => 
                def newExpr = <[ $expr; __constructorParams.Add($(head : dyn)); ]>;
                addParams(tail, newExpr);                
              | [] => expr
              }              
          }          
          
          def assignments = addParams(constructorParams, ctor.Body);
          ctor.Body = <[ $assignments ]>;          
          
          def tb = type :> TypeBuilder;
          tb.Define(<[ decl: __constructorParams : List[object] = List.[object]() ]>);
          tb.Compile();
          
          def header = $<#function $(type.Name)(..$(constructorParams)) { #>;          
          def body = $<#  ..$(exprs1; "\n  ") #>;
          def footer = <#}; #>;
          
$<#
$header
var self = this;
$body
$constructorBody
$footer
#>
      }
      
      def vmTypeBody = createJsTypeBody(tb);
      def otherTypeBodies = tb.GetNestedTypes(BF.Public|BF.NonPublic|BF.Instance)
                              .Filter(t => t.Name != "Server")
                              .Map(t => <[ sb.AppendLine($(createJsTypeBody(t))) ]>);
      
      def toTypedObjectFunction = 
<#
function ToTypedObject(obj) {
    if(!!obj.$type) {
        var typename = obj.$type.replace(/.*\+(.+),.+/, "$1");
        var params = [];
        for(var p in obj)
            if(obj.hasOwnProperty(p)) {
                params.push('ToTypedObject(obj.' + p + ')');
            }
        return eval('new ' + typename + '(' + params.slice(1).join() + ')');
    }               
    if(obj instanceof Array) {
        var newArr = [];
        for (var i=0, l = obj.length; i < l; newArr.push(ToTypedObject(obj[i++])));
        return newArr;
    }
    return obj;
};
#>;
      def applyBindings = 
$<#    
    ko.applyBindings(new $(tb.Name)({0}));
#>;
      _ = tb.DefineWithSource(<[ decl:
        public GetViewModelScript() : string
        {
          def sb = System.Text.StringBuilder();
          _ = sb.AppendLine($toTypedObjectFunction);
          { ..$otherTypeBodies }
          _ = sb.AppendLine($vmTypeBody);
          def paramList = __constructorParams.Map(obj => "ToTypedObject(" + Utils.ToJson(obj) + ")");
          _ = sb.AppendLine(string.Format($applyBindings, $"..$(paramList)"));
          sb.ToString()
        }
        ]>);
        
    }    
        
    public GetMethodJsAST(typer : Typer, type : TypeInfo, method : MethodBuilder, lambdas : Dictionary[string, JsAST.Lambda]) : JsAST 
    {        
        match(method.Header.Body) { 
        | FunBody.Typed(typedBody) => 
            mutable jsAst = JsASTBuilder.Build(typedBody, lambdas);
            jsAst = JsASTHelper.LabelsToNamedWhile(jsAst);
            jsAst = JsASTHelper.TransformBottomUp(jsAst);            
            jsAst = JsASTHelper.FlattenAndRemoveVoids(jsAst);
            jsAst = JsASTHelper.RemoveEmptyBranches(jsAst);
            
            when(!(method.Header.ReturnType is FixedType.Void()) && !method.IsConstructor)
                jsAst = JsASTHelper.MakeReturn(jsAst);
                
            jsAst;        
        | FunBody.Parsed => 
            def oldEmitDebug = typer.Manager.Options.EmitDebug;
            def body = method.Body;
            typer.Manager.Options.EmitDebug = false;
            def methodTyper = Typer(type :> TypeBuilder, null, method, method.Env);
            methodTyper.RunFullTyping();
            typer.Manager.Options.EmitDebug = oldEmitDebug;
            def jsbody = GetMethodJsAST(typer, type, method, lambdas);
            method.Body = body;
            jsbody;
        | _ => 
            Message.Error("Couldn't type body"); 
            JsAST.Void();
        }
    }
    
    public TranslateMethodBody(typer : Typer, type : TypeInfo, meth : MethodBuilder, lambdas : Dictionary[string, JsAST.Lambda]) : string
    {           
        def ast = GetMethodJsAST(typer, type, meth, lambdas);
        ast.Write();
    }
    
    private GetTypeConstructor(type : TypeInfo) : IMethod
    {
        def constructors = type.GetConstructors(BF.Public | BF.Instance);
        when(constructors.Length > 1)
              Message.Error(type.Location, "Multiple constructors are not supported");  
        constructors.FirstOrDefault()
    }    
  }
}
