using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using BF = System.Reflection.BindingFlags;
using TExpr = Nemerle.Compiler.Typedtree.TExpr;

namespace Nemerle.WUI.Reactive
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder)
  {
    ViewModelImpl.DoTransformBeforeInheritance(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder) 
  {
    ViewModelImpl.DoTransformBeforeTypedMembers(tb, Macros.ImplicitCTX())
  }
  
  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  macro ViewModel(tb : TypeBuilder) 
  {
    ViewModelImpl.DoTransform(tb, Macros.ImplicitCTX())
  }
  
  module ViewModelImpl
  {
    Ident = "  ";
    
    public DoTransformBeforeInheritance(tb : TypeBuilder, typer : Typer) : void
    {
      //assert2(false);
      Macros.DefineCTX(typer);
      def vmInterface = <[ ttype: Nemerle.WUI.Reactive.IViewModel ]>;
      def superTypes = tb.GetDirectSuperTypes();
      
      unless (superTypes != null && superTypes.Exists(t => t.Equals(vmInterface)))
        tb.AddImplementedInterface(<[ Nemerle.WUI.Reactive.IViewModel ]>);
    }
    
    public DoTransformBeforeTypedMembers(tb : TypeBuilder, typer : Typer) : void
    {
      //assert2(false);
            
      def processMember(member : ClassMember) : void
      {
        | Field(ty=ty) as field =>
          match (ty)
          {            
            | _ => ()
          }
          
        | _ => ()
      }
      
      match (tb.Ast)
      {
        | TopDeclaration.Class(decls=decls) => foreach (d in decls) processMember(d)
        | _ => ()
      }
    }
    
    public DoTransform(tb : TypeBuilder, typer : Typer) : void
    {
      Macros.DefineCTX(typer);
      
      def serverClass = tb.DeclaredNestedTypes.FirstOrDefault(t => t.Name == "Server");
      def serverMethods = Dictionary();
      when(serverClass != null)
      {          
          def env = typer.Manager.CoreEnv;
          def env = env.EnterIntoNamespace(tb.NamespaceNode);
          def controllerName = tb.Name + "Controller";
          def field = <[ decl: _server : $(serverClass.Name : usesite) = $(serverClass.Name : usesite)() ]>;          
          def ctb = env.Define(<[ decl: 
            public class $(controllerName : usesite) : System.Web.Mvc.Controller
            {}
          ]>);
          ctb.Define(field);
                 
          def ptb = tb.DefineNestedType(<[ decl:
              class ServerProxy
              {}
          ]>);          
          tb.Define(<[ decl: server : ServerProxy = ServerProxy() ]>);
          
          foreach(member in serverClass.GetMembers()) {
              | method is IMethod when !method.IsConstructor && method.DeclaringType.FullName == serverClass.FullName => 
                  def parameters = method.GetParameters().Map(p => <[ $(p.Name : usesite) : $(p.ty : typed) ]>);              
                  def fparms = parameters.Map(PParameter);
                  def methodName = ctb.ParsedName.NewName(method.Name);
                            
                  ctb.Define(<[ decl: 
                    public $(methodName : name) (..$fparms) : System.Web.Mvc.JsonResult 
                    {
                        def result = _server.$(method.Name : dyn)(..$parameters);
                        Json(result, System.Web.Mvc.JsonRequestBehavior.AllowGet);
                    }
                  ]>);
                  
                  serverMethods.Add(method.Name, fparms);
                  def fparms = fparms.Append([<[ parameter: callback : int -> void ]>]);
                  
                  ptb.Define(<[ decl:                   
                    public $(methodName : name) (..$(fparms)) : void
                    {}
                  ]>);
              | _ => ()              
          }
          
          ptb.Compile();
          ctb.Compile();
      }
        
      def convertMethod(name : string, meth : MethodBuilder, isDependent = true) : PExpr
      {
        #region Type method body
        def typer = typer;
        def body = meth.Body;
        def oldEmitDebug = typer.Manager.Options.EmitDebug;
        typer.Manager.Options.EmitDebug = false;
        def methodTyper = Typer(tb, null, meth, meth.Env);
        methodTyper.RunFullTyping();
        typer.Manager.Options.EmitDebug = oldEmitDebug;
        #endregion
        
        //assert2(false);
                
        /*
        def scriptBody =
        if (isDependent)
            match (scriptExprs.DivideLast())
            {
              | ([], last)     => Ident + "return " + last.Trim()
              | (exprs2, last) => $<#..$(exprs2; ";\n");\n$Ident#> + "return " + last.Trim()
            }
        else
          $<#$Ident..$(scriptExprs; $";\n$Ident")#>;
        */
        def scriptBody = match(meth.Header.Body) { 
        | FunBody.Typed(typedBody) =>         
            mutable jsAst = JsASTBuilder.Build(typedBody, false);
            jsAst = JsASTOptimizer.LabelsToSwitch(jsAst);
            jsAst = JsASTOptimizer.Optimize(jsAst);            
            jsAst = JsASTOptimizer.FlattenAndRemoveVoids(jsAst);
            jsAst = JsASTOptimizer.RemoveEmptyBranches(jsAst);
            
            JsASTWriter.Write(jsAst); 
        | _ => Message.Error("Couldn't type body"); "/* Error generating javascript, method body wasn't typed correctly */";
        }
      
        meth.Body = body;
                
        def code = 
          if (isDependent)
          $<#
this.$name = ko.computed(function() {
    return $scriptBody;
}, this);#>
          else
$<#
this.$name = function() {
    $scriptBody;
};#>;
        <[ $(code : string) ]>
      }
      
      assert2(false);
      
      def convertMember(member : IMember) : PExpr
      {
        | meth is MethodBuilder when meth.Name.StartsWith("get_") || meth.Name.StartsWith("set_") => null //TODO: Add property IMethod.IsAccessor
        | meth is MethodBuilder when meth.IsConstructor => null
        | meth is MethodBuilder when meth.ReturnType is FixedType.Void => convertMethod(meth.Name, meth, false)
        | prop is PropertyBuilder when prop.AutoPropertyField.IsSome =>
          //assert2(false);
          def arrayTypes = [<[ ttype: Nemerle.Core.list[_] ]>, <[ ttype: System.Collections.Generic.List[_] ]>];          
          def isArray = arrayTypes.Any(t => prop.Getter.ReturnType.TryUnify(t));
          def ctor = if (isArray) "observableArray" else "observable";
          def prefix = $<#this.$(prop.Name) = ko.$ctor(#>;
          <[ $(prefix : string) 
            + Nemerle.WUI.Reactive.Utils.ToJson(this.$(prop.Ast.name))
            + $(<#);#> : string) ]>
        | prop is PropertyBuilder when prop.CanRead && !prop.CanWrite => convertMethod(prop.Name, prop.GetGetter() :> MethodBuilder)        
        | meth is MethodBuilder when meth.Header.ParametersDeclarations.Length == 0 => convertMethod(meth.Name, meth)          
        | _ =>  null          
      } 
      
      //assert2(false);
      def members = tb.GetMembers(BF.DeclaredOnly | BF.Instance | BF.Public | BF.NonPublic);
      def exprs1 = members.RevMap(convertMember).RevFilter(_ != null);
      def exprs2 = exprs1.Map(e => <[ _ = sb.AppendLine($e) ]>);
      
      _ = tb.DefineWithSource(<[ decl:
        public GetViewModelScript() : string
        {
          def sb = System.Text.StringBuilder();
          _ = sb.AppendLine("function ViewModel() { ");
          { ..$exprs2 }          
          _ = sb.AppendLine("}");
          _ = sb.AppendLine("ko.applyBindings(new ViewModel());");
          sb.ToString()
        }
        ]>);

      _ = tb.DefineWithSource(<[ decl:
        public ToJson() : string
        {
          assert2(false);
          "!!! Not implemented yet !!!"
        }
        ]>);
        
      _ = tb.DefineWithSource(<[ decl:
          protected js(function : string) : string
          {""}
        ]>);
    }
    
    /// Create nested type with given properties and return name of created type.
    public MakeNestedViewModel(tb : TypeBuilder, typer : Typer, typeName : string, props : list[PExpr]) : PExpr
    {
      //assert2(false);
      typer.Manager.MacroColors.PushUseSiteColor();
      
      try
      {
        def makeProp(propDef : PExpr) : ClassMember
        {
          | <[ $(name : name) : $ty ]> => <[ decl: public $(name : name) : $ty { get; set; } ]>
          | _ => Message.FatalError(propDef.Location, "Incorrect format of property defenition. Use: Name : type")
        }
        def name = "T" + typeName;
        def props2 = props.Map(makeProp);
        
        def nested = tb.DefineNestedType(<[ decl:
          [Nemerle.Core.Record, Nemerle.WUI.Reactive.ViewModel]
          public class $(name : dyn) : Nemerle.WUI.Reactive.IViewModel
          {
            ..$props2
          }
          ]>);
          
        nested.Compile();
          
        <[  ]>
      }
      finally { typer.Manager.MacroColors.PopColor(); }
    }
  }
}
